import collections

# Define the grid
grid = [
    ['S', '.', '.', '.', '.'],
    ['.', 'X', 'X', '.', '.'],
    ['.', '.', '.', 'X', '.'],
    ['.', 'X', '.', '.', 'G']
]

# Grid dimensions
rows = len(grid)
cols = len(grid[0])

# Find the start and goal positions
start = None
goal = None
for r in range(rows):
    for c in range(cols):
        if grid[r][c] == 'S':
            start = (r, c)
        elif grid[r][c] == 'G':
            goal = (r, c)

def manhattan_distance(p1, p2):
    """Calculates the Manhattan distance between two points."""
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def greedy_best_first_search(start, goal, grid):
    """
    Finds the shortest path using Greedy Best-First Search.
   
    Args:
        start: The starting coordinates (row, col).
        goal: The goal coordinates (row, col).
        grid: The grid representing the map.
       
    Returns:
        A list of coordinates representing the path from start to goal,
        or None if no path is found.
    """
   
    # Priority queue to store (heuristic_value, current_node)
    # The heuristic value here is the Manhattan distance to the goal.
    open_list = collections.deque([(manhattan_distance(start, goal), start)])
   
    # Dictionary to store the parent of each node for path reconstruction
    came_from = {start: None}
   
    # Set to keep track of visited nodes to avoid cycles
    visited = {start}
   
    path = []
   
    while open_list:
        # Sort the open list based on the heuristic value (Greedy choice)
        open_list = collections.deque(sorted(list(open_list), key=lambda x: x[0]))
       
        # Get the node with the lowest heuristic value
        current_distance, current_node = open_list.popleft()
       
        # Check if we have reached the goal
        if current_node == goal:
            # Reconstruct the path
            path = []
            while current_node is not None:
                path.append(current_node)
                current_node = came_from[current_node]
            return path[::-1] # Reverse the path to get it from start to goal
       
        r, c = current_node
       
        # Define the possible movements (up, down, left, right)
        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
       
        for dr, dc in moves:
            next_r, next_c = r + dr, c + dc
            next_node = (next_r, next_c)
           
            # Check for valid moves
            if 0 <= next_r < rows and 0 <= next_c < cols:
                # Check if the cell is not an obstacle and has not been visited
                if grid[next_r][next_c] != 'X' and next_node not in visited:
                    # Calculate the heuristic value for the next node
                    heuristic_val = manhattan_distance(next_node, goal)
                   
                    # Add the next node to the open list and mark as visited
                    open_list.append((heuristic_val, next_node))
                    visited.add(next_node)
                   
                    # Set the parent of the next node for path reconstruction
                    came_from[next_node] = current_node
   
    return None # No path found

# Run the search algorithm
shortest_path = greedy_best_first_search(start, goal, grid)

# Print the results
if shortest_path:
    print("Path found:")
    for step in shortest_path:
        print(f"-> {step}", end=" ")
    print(f"\nTotal steps: {len(shortest_path) - 1}")
   
    # Visualize the path on the grid
    path_grid = [row[:] for row in grid]
    for r, c in shortest_path:
        if (r, c) != start and (r, c) != goal:
            path_grid[r][c] = '*'
           
    print("\nVisualized path:")
    for row in path_grid:
        print(' '.join(row))
else:
    print("No path found.")

